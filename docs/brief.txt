TS-first workflow runtime with top-notch DX

Context (what already exists)
We have a deterministic execution pipeline (“maker”) that can compile and run helper stages. It supports:
	•	stable ordering (DAG constraints, deterministic tie-breaks)
	•	helper composition by key (extend / overwrite)
	•	helper stages (e.g. extract, transform, load)
	•	stage epilogues (onVisited receives visited helper instance IDs once per kind)
	•	lifecycle stages (makeLifecycleStage(name)) that trigger extension hooks (e.g. prepare, onSuccess, rollback)
	•	MaybePromise semantics across helpers
The pipeline is solid; the problem is DX and product semantics: current usage feels fragmented and plumbing-heavy.

North Star
Create a TS-first “workflow” product that feels cohesive and learnable. The plumbing lives in core and stays mostly invisible. Users compose capabilities via a plugin system. Plugins ship “recipes” that cover real use cases (LLM, tools, retrieval/vector DB, HITL, evaluation, loops such as ToT/agentic). The result should feel closer to ModelFusion/Vercel AI ergonomics (small surface area, type-first, composable) and less like “Python translated to JS”.

Vocabulary (keep verbs/nouns consistent)
	•	Core: the hidden execution pipeline and internal wiring
	•	Workflow: the user-facing runtime a developer instantiates and runs
	•	Plugin: a composable unit that adds capabilities to a Workflow
	•	Recipe: a pre-wired, opinionated plugin bundle representing a known use case
	•	Capability: a concrete feature area provided by plugins (Model, Tool, Retriever, Memory, Evaluator, Trace)
	•	Artefact: the structured data produced as the workflow runs (IR/fragments, traces, scores, tool results)
	•	Run: a single execution instance with inputs, budgets, and outputs
Use these nouns consistently. Use verbs like: compose, register, resolve, execute, trace, score, resume.

Behavioural goals (what we want, not how to implement it)
	•	DX-first: a developer can do something useful in minutes with minimal concepts.
	•	Composable: plugins can be stacked; overrides are explicit and deterministic.
	•	Traceable: every run yields a coherent trace (steps + lifecycle events + diagnostics) without extra work.
	•	Typed: tools, structured outputs, and artefacts should be strongly typed in TS, with a clean schema story.
	•	Loop-friendly: cycles are expressed as “workflow inside a cycle controller” (DAG per iteration; cycle at recipe level).
	•	HITL-ready: workflows can pause/resume cleanly without turning the pipeline into a sleeping daemon.
	•	Retrieval-ready: vector DB and retrieval flow are first-class capabilities (not a pile of glue code).
	•	Minimal public surface: prefer a small set of primitives; avoid an explosion of options.

Non-goals
	•	Recreating every LangChain class 1:1.
	•	Forcing users to wire helper stages or lifecycle stages manually for common cases.
	•	Building a training framework; focus on orchestration, eval, scoring, data capture, and runtime loops.

Developer experience target (illustrative API feel, not final design)
A user should be able to do something like:
	•	Create a Workflow from a Recipe
	•	Compose Plugins (tools, retriever, memory, evaluators)
	•	Run it and get a typed result + trace
	•	Add/override behaviour by adding one plugin (or overriding one key)

Example “feel” (illustrative):

const wf = Workflow.fromRecipe("rag-agent")
  .use(Model.openai({ model: "…" }))
  .use(Tools.web())
  .use(Retriever.vector({ store: "…" }))
  .use(Memory.threadSummary())
  .use(Evals.rubric())
  .use(Trace.console())
  .build();

const out = await wf.run({ input: "…" });

Recipes to cover (use cases the product must “understand”)
Please model a small initial recipe set that covers:
	1.	Simple tool-calling agent (LLM emits ToolCalls IR; runtime dispatches tools)
	2.	RAG with vector DB (chunk/embed/index optional; retrieve/rerank/cite; answer)
	3.	Evaluation run (generate candidates, score, select, report; supports dataset emission)
	4.	HITL gate (auto-score then pause/resume when confidence is low)
	5.	Loop recipe (agent loop or ToT loop expressed as cycle controller around a deterministic inner workflow)

Diagnostics and explainability
The product should expose, by default:
	•	steps (executed helper keys/ids in deterministic order)
	•	diagnostics (structural signals like unused registrations, overrides/shadowing, unresolved dependencies)
	•	lifecycle trace points when recipes opt into them
This should feel natural and not like “debug mode plumbing”.

What I want from you
Please produce a draft plan we can iterate on, not a perfect solution. Specifically:
	1.	A concise product shape: core vs workflow vs plugin vs recipe.
	2.	A proposed minimal public API surface (names, nouns, and a small set of verbs).
	3.	A plugin model that keeps composability and override semantics, while hiding pipeline plumbing under core.
	4.	A small recipe catalogue (the 5 recipes above), each with a short “what it does” and the key artefacts it produces.
	5.	A sketch of how loops and HITL pause/resume fit without breaking determinism.
	6.	The risks/trade-offs you anticipate (DX vs flexibility, type complexity, plugin conflicts, etc.).
	7.	A list of open questions you want us to answer next.

Show what the developer sees, what the system produces, and how plugins compose.